# This -*- makefile -*- is part of Marionnet, a virtual network laboratory
# Copyright (C) 2008, 2009  Luca Saiu
# Updated in 2008 by Marco Stronati
# Updated by Jean-Vincent Loddo

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

COMPILE_OPTIONS += -g
DIRECTORIES_TO_INCLUDE = camlp4 threads lablgtk2 lablglade ocamlbricks
LIBRARIES_TO_LINK = unix threads str lablgtk lablglade ocamlbricks
C_OBJECTS_TO_LINK += does-process-exist-c-wrapper

OCAMLBRICS=$(LIBRARYPREFIX)/ocamlbricks
PP_OPTION = camlp4of -I $(OCAMLBRICS) gettext_extract_pot_p4.cmo -I chip

OBJECTS_TO_LINK = gtkThread
BYTE_PROGRAMS = marionnet.byte chip_example.byte
ROOT_BYTE_PROGRAMS = marionnet-daemon.byte

# To do: these should be enabled for release, but they take too long to
# build every time...
#NATIVE_PROGRAMS = marionnet.native
#ROOT_NATIVE_PROGRAMS = marionnet-daemon.native

#ROOT_PROGRAMS = marionnet-daemon.byte marionnet-daemon.native
OTHER_PROGRAMS_TO_INSTALL =

# menu_factory.ml menu_factory.mli chip.ml are not documented because they
# get ocamldoc (with -pp camlp4of) confused
UNDOCUMENTED=version.ml gui.ml chip_example.expanded.ml chip_example.ml menu_factory.ml menu_factory.mli chip.ml

# Before building the main targets we have to create the machine-generated
# sources:
MANUALLY_PRE_COPY_IN_build =     \
  gettext_extract_pot_p4.conf    \
  include_type_definitions_p4.ml \
  include_as_string_p4.ml        \
  chip/chip_parser_p4.ml         \
  does-process-exist/does-process-exist-c-wrapper.c \
  scripts/can-directory-host-sparse-files.sh

MANUALLY_PRE_MAKE_IN_build =      \
  include_type_definitions_p4.cmo \
  include_as_string_p4.cmo        \
  chip/chip_parser_p4.cmo         \
  chip/chip_example.expanded.ml   \
  does-process-exist-c-wrapper.o

MANUALLY_POST_MAKE_IN_build = chip/chip_example.expanded.byte chip/chip_example.expanded.mli

marionnet.byte marionnet.native : manually_pre_actions version.ml gui.ml

########## Manually generated targets (not through ocamlbuild)

_build/include_type_definitions_p4.cmo: include_type_definitions_p4.ml
	ocamlc -c -I +camlp4 -pp camlp4of -o $@ $<

_build/include_as_string_p4.cmo: include_as_string_p4.ml
	ocamlc -c -I +camlp4 -pp camlp4of -o $@ $<

# _build/extract_pot_p4.cmo: gettext/extract_pot_p4.ml
# 	ocamlc -c -I +camlp4 -pp camlp4of camlp4lib.cma -o $@ $<

_build/chip/chip_parser_p4.cmo: chip/chip_parser_p4.ml
	ocamlc -c -I +camlp4 -pp camlp4of camlp4lib.cma -o $@ $<

_build/chip/chip_example.expanded.ml : chip/chip_example.ml _build/chip/chip_parser_p4.cmo
	camlp4of -I _build/chip/ -printer Camlp4OCamlRevisedPrinter chip_parser_p4.cmo -o $@ $<

CHIP_CMDLINE=-custom -I _build/chip/ -I _build/gettext/ -I +threads unix.cma threads.cma \
  -I +ocamlbricks ocamlbricks.cma recursive_mutex.cmo \
  meta.cmo initialization.cmo global_options.cmo chip.cmo

_build/chip/chip_example.expanded.byte : _build/chip/chip_example.expanded.ml
	ocamlc -thread -pp camlp4rf -I _build/ $(CHIP_CMDLINE) -o $@ $<

_build/chip/chip_example.expanded.mli : _build/chip/chip_example.expanded.ml
	ocamlc -i -thread -pp camlp4rf -I _build/ $(CHIP_CMDLINE) $< >$@

run: marionnet.byte
	(export WORKING=`pwd`; OCAMLRUNPARAM="b" $$WORKING/_build/marionnet.byte) | tee /tmp/LOG

runexam: marionnet.byte
	(export WORKING=`pwd`; OCAMLRUNPARAM="b" $$WORKING/_build/marionnet.byte --exam) | tee /tmp/LOG

runopt: marionnet.native
	(export WORKING=`pwd`; $$WORKING/_build/marionnet.native) | tee /tmp/LOG

run-daemon: marionnet-daemon.byte
	sudo _build/marionnet-daemon.byte

# version.ml is automatically generated:
version.ml: VERSION BUILD-TIME
	@(echo -e "(* This file is automatically generated. Please don't edit it. *)" > $@; \
	echo -e "" >> $@; \
	echo -en "let version = \"" >> $@; \
	for x in `cat VERSION`; do echo -n "$$x" >> $@; done; \
	echo -e "\";;" >> $@; \
	echo -en "let build_time = \"" >> $@; \
	for x in `cat BUILD-TIME`; do echo -n "$$x " >> $@; done; \
	echo -e "\";;" >> $@)

VERSION: META
	@($(call READ_META, name, version); \
	echo "$$version" > $@)

BUILD-TIME:
	@(echo 'built in '`date +"%B %Y"` > $@)

# We need to patch the file generated by Glade, so that image pathnames
# follow our conventions:
share/gui.glade.patched: gui/gui.xml VERSION BUILD-TIME
	@(cat gui/gui.xml | \
	sed s/name=\"pixbuf\"\>/name=\"pixbuf\"\>images\\//g | \
	sed s/name=\"icon\"\>/name=\"icon\"\>images\\//g | \
	sed "s/QQVERSIONQQ/`cat VERSION`/g" | \
	sed "s/QQDATEQQ/`cat BUILD-TIME`/g" > $@)

# This is the name of the Glade->OCaml code generator:
GLADE2ML = lablgladecc2

# gui.ml is automatically generated from the patched Glade file:
gui.ml: share/gui.glade.patched
	@(cd share; $(GLADE2ML) gui.glade.patched > ../$@)

gui-help: gui.ml
	ocamlc -i -I +lablgtk2 lablgtk.cma gui.ml | grep -v "val" | grep -v "[0-9]"

# Clean all the automatically-generated sources:
clean-local: clean-mo clean-doc
	@(rm -f VERSION BUILD-TIME version.ml; \
	rm -f share/gui.glade.patched gui.ml)

# ==============gettext stuff=============

install-local: install-mo
uninstall-local: uninstall-mo

# How to build C modules:
_build/does-process-exist-c-wrapper.o: does-process-exist/does-process-exist-c-wrapper.c
	@$(call READ_CONFIG, ocaml_sources); \
	(mkdir _build &> /dev/null || true) && \
	gcc -g -O3 -I $$ocaml_sources -o $@ -c $^

_build/marionnet.pot: marionnet.byte
	msgcat --use-first $(shell find _build/ -name "*.ml.pot") > $@

pot: _build/marionnet.pot
	cp _build/marionnet.pot po/messages.pot

main-local: pot

# Useful to discover widgets containing translatable strings
gui.po: gui/gui.xml
	xml2po $< > /tmp/$@
	@echo "Generated file: /tmp/$@"

# We can take the list of supported languages from po/LINGUAS.
# Notice that this macro is always invoked from the po/ subdirectory:
LANGUAGES = $$( grep -v ^\#.*$$ LINGUAS )

compile-mo:
	@(cd po/; \
	for i in $(call LANGUAGES); \
	do (msgfmt $$i.po && mv messages.mo $$i.mo || exit -1) && \
	echo "Compiled "$$i.mo; \
	done;)

update-po: pot
	@(cd po/; \
	for i in $(call LANGUAGES); \
	do (msgmerge --no-fuzzy-matching --sort-by-file --update $$i.po messages.pot || exit -1) && \
	echo "Updated "$$i.po; \
	done;)

install-mo: compile-mo
	@($(call READ_CONFIG,localeprefix); \
	cd po/; \
	for i in $(call LANGUAGES); \
	do ((mkdir -p $$localeprefix/$$i/LC_MESSAGES && cp $$i.mo $$localeprefix/$$i/LC_MESSAGES/marionnet.mo) || exit -1) && \
	echo "Installed "$$i; \
	done;)

clean-mo:
	@(cd po/; \
	rm -rf *.mo *~ *.pot;)

uninstall-mo:
	@($(call READ_CONFIG,localeprefix); \
	for i in $(call LANGUAGES); \
	do rm -f $$localeprefix/$$i/LC_MESSAGES/marionnet.mo; \
	echo "Uninstalled "$$i; \
	done;)

######### documentation ##############

#build texinfo developer documentation in one default format
documentation-local: documentation-html-no-split

#build texinfo developer documentation in one all formats
documentation-all: documentation-pdf documentation-html-split documentation-html-no-split

#multi page html output
#the makeinfo command need to be executed in the same directory as img, otherwise it doesn't find any image
documentation-html-split:
	@(cd doc-src; \
	  makeinfo --html --force --no-validate \
	   documentation.texi -o ../doc/documentation/; \
	  cp -r img/ ../doc/documentation/; \
	  cd ..;)

#one page html output
documentation-html-no-split:
	@(cd doc-src; \
	  makeinfo --html --force --no-validate --no-split \
           documentation.texi -o ../doc/documentation.html; \
	  cp -r img/ ../doc/; \
	  cd ..;)

#pdf output
documentation-pdf:
	@(cd doc-src; \
	  texi2dvi --pdf -E --build=local \
	   documentation.texi -o ../doc/documentation.pdf; \
	  rm -f documentation.aux documentation.cp documentation.cps \
	        documentation.fn documentation.ky documentation.log  \
		documentation.pg documentation.toc documentation.tp  \
		documentation.vr;)

clean-doc:
	@(rm -rf doc/* )

#convert and resize images from ps and eps to png
images: dot
	@(mkdir doc/img; \
	  cp doc-src/img/*.png doc/img/; \
	  for i in $$(ls doc-src/img-src/*{ps,eps}); \
          do convert $$i doc/img/$$(basename $${i%.*}.png); \
          done)


# #compile dot sources
dot:
	@(for i in $$(ls doc-src/img-src/*.dot); \
	do dot -Tsvg $$i -o doc-src/img-src/$$(basename $$i .dot).svg; \
           convert -geometry 300x300 -density 150 -antialias doc-src/img-src/$$(basename $$i .dot).svg \
           doc-src/img/$$(basename $$i .dot).png; \
        done; \
        #rm doc-src/img-src/*.svg \
        )
